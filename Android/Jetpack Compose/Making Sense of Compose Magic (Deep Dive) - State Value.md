# Making Sense of Compose Magic (Deep Dive)

It’s almost magical how Compose automatically updates the UI when you change a state value, but how does it achieve this? Let’s find out.

## A State of mind

In Jetpack Compose, if you want a value to persist across recompositions, you pass it to `remember` wrapped in `mutableStateOf()`. For example, `val enabled = remember { mutableStateOf(false) }`, but how does it work?"

**_Let’s Deep Dive_**

```kotlin
/**
 * The MutableState class is a single value holder whose reads and writes are observed by
 * Compose. Additionally, writes to it are transacted as part of the [Snapshot] system.
 *
 * @param value the initial value for the [MutableState]
 * @param policy a policy to controls how changes are handled in mutable snapshots.
 */
fun <T> mutableStateOf(
    value: T,
    policy: SnapshotMutationPolicy<T> = structuralEqualityPolicy()
): MutableState<T> = createSnapshotMutableState(value, policy)
```

As you can see, `mutableStateOf()` defines two parameters: first, the `value: T`, which is the object it holds, and second, the `policy: SnapshotMutationPolicy`, which we usually don't need to worry about because it has a default value. However, we will delve into it in a moment.

The Compose Runtime keeps track of the `MutableState` object in the current composition. This means that if you change the value held by `MutableState`, the Compose Runtime will detect the change and schedule a recomposition. This is where the second parameter, `policy`, comes into play. Compose uses it to check if the value has changed.

**_Let’s Deep Dive_**

```kotlin
/**
 * A policy to treat values of a [MutableState] as equivalent if they are structurally (==) equal.
 *
 * Setting [MutableState.value] to its current structurally (==) equal value is not considered
 * a change. When applying a [MutableSnapshot], if the snapshot changes the value to the
 * equivalent value the parent snapshot has is not considered a conflict.
 */
@Suppress("UNCHECKED_CAST")
fun <T> structuralEqualityPolicy(): SnapshotMutationPolicy<T> =
    StructuralEqualityPolicy as SnapshotMutationPolicy<T>

private object StructuralEqualityPolicy : SnapshotMutationPolicy<Any?> {
    override fun equivalent(a: Any?, b: Any?) = a == b

    override fun toString() = "StructuralEqualityPolicy"
}
```

As you can see, `structuralEqualityPolicy()` returns a `SnapshotMutationPolicy<T>`, which includes an `equivalent()` method. This method takes two values, `a` and `b`, where one of them is the new value we're setting, and the other is the old value held by `MutableState<T`. Ideally, Compose Runtime provides these values.

`equivalent()` simply checks if `a == b`. If this condition is false, Compose will schedule the recomposition; otherwise, it won't. This also means that the `equals()` method of your Data Types should be consistent. If you're using data classes, there's no issue, but if not, you can override `equals()` or supply your own `SnapshotMutationPolicy` by implementing that interface.

However, recomposition alone doesn’t work. Changing a `State<T>` object causes recomposition, but the new value isn't automatically supplied. Instead, our `State<T>` will be reinitialized to the old value, as if nothing has happened.

## Lets Remember Something

It turns out that composables can have their own memory, so during recomposition, they can retrieve the old value stored in that memory and use it. To make Compose track your value and save it in the composable’s memory, you need to use `State<T>` with `remember{}`.

For example: `val enabled = remember { mutableStateOf(false)}`.

**_Let’s Deep Dive_**

```kotlin
/**
 * Remember the value produced by [calculation]. [calculation] will only be evaluated during the composition.
 * Recomposition will always return the value produced by composition.
 */
@Composable
inline fun <T> remember(calculation: @DisallowComposableCalls () -> T): T = currentComposer.cache(false, calculation)
```

The `remember()` function takes a calculation as a lambda and uses the `currentComposer`. This `currentComposer` references an instance of the `Composer` interface, which is targeted by the Compose Kotlin compiler plugin and utilized by code generation helpers. It's important not to call `currentComposer` directly, as the runtime assumes that calls to it are generated by the compiler and, therefore, do not contain extensive validation logic.

In addition, `cache()` is an extension function of the `Composer`. It stores a value in the composition data of a composition.

```kotlin

/**
 * A Compose compiler plugin API. DO NOT call directly.
 *
 * Cache, that is remember, a value in the composition data of a composition. This is used to
 * implement [remember] and used by the compiler plugin to generate more efficient calls to
 * [remember] when it determines these optimizations are safe.
 */
@ComposeCompilerApi
inline fun <T> Composer.cache(invalid: Boolean, block: () -> T): T {
    @Suppress("UNCHECKED_CAST")
    return rememberedValue().let {
        if (invalid || it === Composer.Empty) {
            val value = block()
            updateRememberedValue(value)
            value
        } else it
    } as T
}
```

Now, this is where the remembered value comes from. The `rememberedValue()` function returns a value saved in the cache of a composable. Here, it essentially checks whether or not we already have that value. If the value is not present in the cache, the calculation takes place, and the value is updated. Otherwise, the old value is returned.

source: https://blog.devgenius.io/making-sense-of-compose-magic-deep-dive-b03873910a67
